// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ParticleToPoint
#pragma kernel PointsToDisplacement_X
#pragma kernel PointsToDisplacement_Y
#pragma kernel ApplyWaveParicles

#define WAVEPARTICLESPEED 4
#define WAVEPARTICLERADIUS 2.0
#define WAVEPARTICLEAMP 0.5

#define METER_PER_PIXEL 0.125 

RWTexture2DArray<float4> _DisplaceArray;
RWTexture2DArray<float4> _DerivativeArray;
RWTexture2DArray<float4> _VelocityArray;
//RWTexture2DArray<float4> _DerivativeArray;
//RWTexture2DArray<float4> _NormalArray;
//RWTexture2DArray<float4> _VelocityArray;
//this map will be used though all LODs
//RWTexture2D<float4> _BaseDerivativeMap;//Previous LOD DeriMap ,R: Dxx, G:Dyy, B:Dzx, A:Dzy
//Texture2D<float4> _BaseDerivativeMap_Sample;//Same as _BaseDerivativeMap just for sampling
RWTexture2DArray<float4> _WaveParticleArray;
//sampler 
SamplerState linearClampSampler;

uint _WaveParticleCount;
struct WaveParticle
{
    float DispersionAngle;
    float2 Direction;
    float2 Origin;
};
StructuredBuffer<WaveParticle> _WaveParticleBuffer;

float3 _CenterPos;
float4 _LODParams;//x LODCOUNT ,y LODIndex, z LODSize.
float4 _TimeParams;

float DistanceSquared2(float2 pA, float2 pB)
{
    return dot(pA - pB, pA - pB);
}

float4 GetBilinearWeight(float2 UV)
{
    float2 xy = UV - floor(UV);

    //Weights for p00,p01,p10,p11

    float4 Weightxy = float4(
        (1 - xy.x) * (1 - xy.y),
        (1 - xy.x) * (xy.y),
        (xy.x)* (1 - xy.y),
        (xy.x) * (xy.y));

    return Weightxy;
}

[numthreads(128, 1, 1)]
void ParticleToPoint(uint3 id : SV_DispatchThreadID)
{

    
    //WaveParticle
    float2 ParticlePos = _WaveParticleBuffer[id.x].Origin + WAVEPARTICLESPEED * _WaveParticleBuffer[id.x].Direction * _TimeParams.x;
    float ParticleAmp = WAVEPARTICLEAMP;
    float ParticleRadius = WAVEPARTICLERADIUS;

    //LOD
    float CurrentLODSize = _LODParams.z;
    float LODIndex = _LODParams.y;
    

    //Get dims
    uint width, height, elements;
    _DisplaceArray.GetDimensions(width, height, elements);

    float2 UV = ((ParticlePos-_CenterPos.xz) / CurrentLODSize + 0.5f) * width;


    //_DisplaceArray[uint3(id.x, 0, LODIndex)] = float4(1.0, 100.0, 1.0, 1.0);


    if (max(UV.x, UV.y) < (float)width)
    {
        float4 B_Weight = GetBilinearWeight(UV);

        uint2 P00 = uint2(floor(UV.x), floor(UV.y));
        uint2 P01 = uint2(floor(UV.x), ceil(UV.y));
        uint2 P10 = uint2(ceil(UV.x), floor(UV.y));
        uint2 P11 = uint2(ceil(UV.x), ceil(UV.y));

        float4 displaceP00 = _DisplaceArray[uint3(P00, LODIndex)];
        float4 displaceP01 = _DisplaceArray[uint3(P01, LODIndex)];
        float4 displaceP10 = _DisplaceArray[uint3(P10, LODIndex)];
        float4 displaceP11 = _DisplaceArray[uint3(P11, LODIndex)];

        displaceP00.a += ParticleAmp * B_Weight[0];
        displaceP01.a += ParticleAmp * B_Weight[1];
        displaceP10.a += ParticleAmp * B_Weight[2];
        displaceP11.a += ParticleAmp * B_Weight[3];

        _DisplaceArray[uint3(P00, LODIndex)] = displaceP00;
        _DisplaceArray[uint3(P01, LODIndex)] = displaceP01;
        _DisplaceArray[uint3(P10, LODIndex)] = displaceP10;
        _DisplaceArray[uint3(P11, LODIndex)] = displaceP11;
    }
}


[numthreads(32,32,1)]
void PointsToDisplacement_X (uint3 id : SV_DispatchThreadID)
{
    float ParticleRadius = WAVEPARTICLERADIUS;
    

    uint LODCount = (uint)_LODParams.x;
    float CurrentLODSize = _LODParams.z;
    float LODIndex = _LODParams.y;

    //Get dims
    uint width, height, elements;
    _DisplaceArray.GetDimensions(width, height, elements);

    int UV_PRadius = floor(ParticleRadius / CurrentLODSize * width);
    
    //float4 DisplaceData = _DisplaceArray[uint3(id.x, id.y, LODIndex)];
    float CombinedAmp = _DisplaceArray[uint3(id.x, id.y, LODIndex)].w;
    float CombinedXoffset = 0.0;
    //unroll[16]
    for (int i = 1; i < UV_PRadius; i++)
    {

        float neighbouroffset_right = _DisplaceArray[uint3(id.x + i, id.y, LODIndex)].a;
        float neighbouroffset_left = _DisplaceArray[uint3(id.x - i, id.y, LODIndex)].a;
          
        float x = (float)i / (float)UV_PRadius;
        float cheapstep = pow(1.0 - x*x, 2);
        float cheapstep_derivative = (1.0 - x * x) * (-2*x);

        float weight_height = cheapstep;
        float weight_X = cheapstep_derivative * 0.1;

        CombinedAmp += cheapstep * (neighbouroffset_left + neighbouroffset_right);
        CombinedXoffset +=  -cheapstep_derivative * neighbouroffset_right + cheapstep_derivative * neighbouroffset_left;
    }

    float4 WPDisplacement = float4(CombinedXoffset, CombinedAmp, 0.0, 0.0);


    _WaveParticleArray[uint3(id.x, id.y, LODIndex + LODCount/2)] = WPDisplacement;

    /*

    GetCheapStepWeightInRadius(UV_PRadius, )
    //D3D CoordSystem
    float3 WPos = float3(
        (id.x / float(width) - 0.5f) * CurrentLODSize,
        0.0f,
        (id.y / float(height) - 0.5f) * CurrentLODSize
        ) + _CenterPos;

    float4 DisplaceSample = _DisplaceArray[uint3(id.xy, LODIndex)];

    for (uint i = 0; i < _WaveParticleCount; i++)
    {
        WPPos = _WaveParticleBuffer[i].Origin + WAVEPARTICLESPEED * _WaveParticleBuffer[i].Direction * _TimeParams.x;
        
        float distanceSqr = DistanceSquared2(WPPos, WPos.xz) / (WRadius * WRadius);

        float cheapstep = pow(1 - distanceSqr, 2);
        float cheapstep_derivate = (1 - distanceSqr)*(-2*sqrt(distanceSqr));

        float displaceY = cheapstep * WPAmp;
        float2 toWP = WPPos - WPos.xz;
        float2 displaceXZ = abs(cheapstep_derivate) * WPAmp * normalize(toWP)  * 0.25;

        float3 displace = float3(displaceXZ.x, displaceY, displaceXZ.y);
        DisplaceSample.xyz += distanceSqr > 1.0 ? 0.0 : displace;
    }

    

    _DisplaceArray[uint3(id.xy, LODIndex)] = DisplaceSample;
    */
}

[numthreads(32, 32, 1)]
void PointsToDisplacement_Y(uint3 id : SV_DispatchThreadID)
{
    float ParticleRadius = WAVEPARTICLERADIUS;

    uint LODCount = (uint)_LODParams.x;
    float CurrentLODSize = _LODParams.z;
    float LODIndex = _LODParams.y;

    //Get dims
    uint width, height, elements;
    _DisplaceArray.GetDimensions(width, height, elements);

    int UV_PRadius = floor(ParticleRadius / CurrentLODSize * width);

    float4 WPDisplaceData = _WaveParticleArray[uint3(id.x, id.y, LODIndex + LODCount/2)];
    float CombinedAmp = WPDisplaceData.y;
    float CombinedXoffset = WPDisplaceData.x;
    float CombinedYoffset = 0.0;
    //unroll[16]
    
    for (int i = 1; i < UV_PRadius; i++)
    {

        float4 neighbourDisplace_up = _WaveParticleArray[uint3(id.x, id.y + i, LODIndex + LODCount/2)];
        float4 neighbourDisplace_down = _WaveParticleArray[uint3(id.x, id.y - i, LODIndex + LODCount/2)];

        float x = (float)i / (float)UV_PRadius;
        float cheapstep = pow(1.0 - x * x, 2);
        float cheapstep_derivative = (1.0 - x * x) * (-2 * x);

        float weight_height = cheapstep;
        float weight_X = cheapstep_derivative * 0.1;

        CombinedAmp += cheapstep * (neighbourDisplace_up.y + neighbourDisplace_down.y);
        CombinedXoffset += cheapstep * neighbourDisplace_up.x + cheapstep * neighbourDisplace_down.x;
        CombinedYoffset += -cheapstep_derivative * neighbourDisplace_up.y + cheapstep_derivative * neighbourDisplace_down.y;

    }

    float4 WPDisplacement = float4(CombinedXoffset, CombinedAmp, CombinedYoffset, 0.0);

    _WaveParticleArray[uint3(id.x, id.y, LODIndex)] = WPDisplacement;

    float4 Displace = _DisplaceArray[uint3(id.x, id.y, LODIndex)];

    Displace += WPDisplacement;

    _DisplaceArray[uint3(id.x, id.y, LODIndex)] = Displace;
    
}

[numthreads(32, 32, 1)]
void ApplyWaveParicles(uint3 id : SV_DispatchThreadID)
{
    float ParticleRadius = WAVEPARTICLERADIUS;

    uint LODCount = (uint)_LODParams.x;
    float CurrentLODSize = _LODParams.z;
    float LODIndex = _LODParams.y;

    //Get dims
    uint width, height, elements;
    _DisplaceArray.GetDimensions(width, height, elements);

    float3 WP_D_center = _WaveParticleArray[uint3(id.x, id.y, LODIndex)].rgb;
    float3 WP_D_left = _WaveParticleArray[uint3(id.x-1, id.y, LODIndex)].rgb;
    float3 WP_D_right = _WaveParticleArray[uint3(id.x+1, id.y, LODIndex)].rgb;
    float3 WP_D_up = _WaveParticleArray[uint3(id.x, id.y+1, LODIndex)].rgb;
    float3 WP_D_down = _WaveParticleArray[uint3(id.x, id.y-1, LODIndex)].rgb;

    float unit = METER_PER_PIXEL * pow(2, LODIndex)*2;

    float Dxx = (WP_D_right.x - WP_D_left.x)/unit;
    float Dyy = (WP_D_up.y - WP_D_down.y)/unit;
    float Dxy = (WP_D_up.x - WP_D_down.x)/unit;
    float Dyx = (WP_D_right.y - WP_D_left.y)/unit;
    float Dzx = (WP_D_right.z - WP_D_left.z)/unit;
    float Dzy = (WP_D_up.z - WP_D_down.z)/unit;
    
    float4 derivates = _DerivativeArray[uint3(id.x, id.y, LODIndex)];
    float4 velocities = _VelocityArray[uint3(id.x, id.y, LODIndex)];
    derivates += float4(Dxx, Dyy, Dzx, Dzy);
    velocities += float4(0.0, 0.0, Dxy, Dyx);
    _DerivativeArray[uint3(id.x, id.y, LODIndex)] = derivates;
    _VelocityArray[uint3(id.x, id.y, LODIndex)] = velocities;
}
