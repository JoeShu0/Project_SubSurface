// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define WaveParticleSpeed 2.0
#define WaveParticleRadius 2.0
#define WaveParticleAmp 1.0


RWTexture2DArray<float4> _DisplaceArray;
//RWTexture2DArray<float4> _DerivativeArray;
//RWTexture2DArray<float4> _NormalArray;
//RWTexture2DArray<float4> _VelocityArray;
//this map will be used though all LODs
//RWTexture2D<float4> _BaseDerivativeMap;//Previous LOD DeriMap ,R: Dxx, G:Dyy, B:Dzx, A:Dzy
//Texture2D<float4> _BaseDerivativeMap_Sample;//Same as _BaseDerivativeMap just for sampling

//sampler 
SamplerState linearClampSampler;

uint _WaveParticleCount;
struct WaveParticle
{
    float DispersionAngle;
    float2 Direction;
    float2 Origin;
};
StructuredBuffer<WaveParticle> _WaveParticleBuffer;

float3 _CenterPos;
float4 _LODParams;//x LODCOUNT ,y LODIndex, z LODSize.
float4 _TimeParams;

float DistanceSquared2(float2 pA, float2 pB)
{
    return dot(pA - pB, pA - pB);
}

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    
    float2 WPPos = float2(5.0, 5.0);
    float WPAmp = WaveParticleAmp;
    float WRadius = WaveParticleRadius; 

    uint LODCount = (uint)_LODParams.x;
    float CurrentLODSize = _LODParams.z;
    float LODIndex = _LODParams.y;

    //Get dims
    uint width, height, elements;
    _DisplaceArray.GetDimensions(width, height, elements);

    //D3D CoordSystem
    float3 WPos = float3(
        (id.x / float(width) - 0.5f) * CurrentLODSize,
        0.0f,
        (id.y / float(height) - 0.5f) * CurrentLODSize
        ) + _CenterPos;

    float4 DisplaceSample = _DisplaceArray[uint3(id.xy, LODIndex)];

    for (uint i = 0; i < _WaveParticleCount; i++)
    {
        WPPos = _WaveParticleBuffer[i].Origin + WaveParticleSpeed * _WaveParticleBuffer[i].Direction * _TimeParams.x;
        
        float distanceSqr = DistanceSquared2(WPPos, WPos.xz) / (WRadius * WRadius);

        float cheapstep = pow(1 - distanceSqr, 2);
        float cheapstep_derivate = (1 - distanceSqr)*(-2*sqrt(distanceSqr));

        float displaceY = cheapstep * WPAmp;
        float2 toWP = WPPos - WPos.xz;
        float2 displaceXZ = abs(cheapstep_derivate) * WPAmp * normalize(toWP)  * 0.25;

        float3 displace = float3(displaceXZ.x, displaceY, displaceXZ.y);
        DisplaceSample.xyz += distanceSqr > 1.0 ? 0.0 : displace;
    }

    

    _DisplaceArray[uint3(id.xy, LODIndex)] = DisplaceSample;
}
