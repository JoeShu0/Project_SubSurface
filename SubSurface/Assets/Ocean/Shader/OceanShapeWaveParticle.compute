// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

RWTexture2DArray<float4> _DisplaceArray;
//RWTexture2DArray<float4> _DerivativeArray;
//RWTexture2DArray<float4> _NormalArray;
//RWTexture2DArray<float4> _VelocityArray;
//this map will be used though all LODs
//RWTexture2D<float4> _BaseDerivativeMap;//Previous LOD DeriMap ,R: Dxx, G:Dyy, B:Dzx, A:Dzy
//Texture2D<float4> _BaseDerivativeMap_Sample;//Same as _BaseDerivativeMap just for sampling

//sampler 
SamplerState linearClampSampler;

float3 _CenterPos;
float4 _LODParams;//x LODCOUNT ,y LODIndex, z LODSize.

float DistanceSquared2(float2 pA, float2 pB)
{
    return dot(pA - pB, pA - pB);
}

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    
    float2 WPPos = float2(5.0, 5.0);
    float WPAmp = 2.0f;
    float WRadius = 2.0f; 

    uint LODCount = (uint)_LODParams.x;
    float CurrentLODSize = _LODParams.z;
    float LODIndex = _LODParams.y;

    //Get dims
    uint width, height, elements;
    _DisplaceArray.GetDimensions(width, height, elements);

    //D3D CoordSystem
    float3 WPos = float3(
        (id.x / float(width) - 0.5f) * CurrentLODSize,
        0.0f,
        (id.y / float(height) - 0.5f) * CurrentLODSize
        ) + _CenterPos;

    float4 DisplaceSample = _DisplaceArray[uint3(id.xy, LODIndex)];

    for (int i = 0; i < 1; i++)
    {
        float distanceSqr = DistanceSquared2(WPPos, WPos.xz) / (WRadius * WRadius);

        float cheapstep = pow(1 - distanceSqr, 2);

        float displaceY = cheapstep * WPAmp;
        float2 toWP = WPPos - WPos.xz;
        float2 displaceXZ = (1-cheapstep) * WPAmp * 0.25 * normalize(toWP)  * 0.5;

        float3 displace = float3(displaceXZ.x, displaceY, displaceXZ.y);
        DisplaceSample.xyz += distanceSqr > 1.0 ? 0.0 : displace;
    }

    

    _DisplaceArray[uint3(id.xy, LODIndex)] = DisplaceSample;
}
