// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> _BaseDisplace;//Previous LOD DispMap, RGB:displacement, A: Dxy
//Texture2D<float4> _BaseNormal;//Previous LOD normal and foam Map, RGB:normal A:foam
//Texture2D<float4> _CurrNormal;//Same as _NormalMap just for sampling

//ExtraArray output for physics sampling(or  we will use this for all later stuff)
RWTexture2DArray<float4> _DisplaceArray;
RWTexture2DArray<float4> _DerivativeArray;
RWTexture2DArray<float4> _NormalArray;

//this map will be used though all LODs
RWTexture2D<float4> _BaseDerivativeMap;//Previous LOD DeriMap ,R: Dxx, G:Dyy, B:Dzx, A:Dzy
Texture2D<float4> _BaseDerivativeMap_Sample;//Same as _BaseDerivativeMap just for sampling

//sampler 
SamplerState linearClampSampler;

RWTexture2D<float4> _DisplaceMap;//Displace Mapout for current LOD = disp + B_disp
RWTexture2D<float4> _NormalMap;//Normal out for current LOD normal and foam RGB:normal A:foam
//NormalMap will not be used by next LOD, but will be used by current LOD for foam fading
//Dxx.etc will add from previous LOD (A+B)' = A' + B'
//****Normal Cal****
//float3 tangent = normalize(float3(1.0f, 0.0f, 0.0f) + float3(Dxx, Dzx, Dxy));
//float3 binormal = normalize(float3(0.0f, 0.0f, 1.0f) + float3(Dxy, Dzy, Dyy));
//float3 normal = normalize(cross(binormal, tangent));
//****foam mask****
//float JacobianDet = (1 + Dxx) * (1 + Dyy) - (Dxy) * (Dxy);
//float FoamMask = clamp(1.0f - JacobianDet,0.0,1.0) * 0.1f + _NormalMap[id.xy].a * 0.9f ;

//Texture2D<float4> NoiseFoam;
//SamplerState samplerNoiseFoam;


float3 _CenterPos;
float4 _LODParams;//x LODCOUNT ,y LODIndex, z LODSize.
//float _LODSize;
//int _LODIndex;
float _LODWaveAmpMul;
float _Time;
float _DeltaTime;

float4 _FoamParams;//x is the inverse foam fade time, x is foam banding offset, y is the foam banding power

int _WaveCount;
struct Wave
{
    float WaveLength;
    float Amplitude;
    float Speed;
    float2 Direction;
};
StructuredBuffer<Wave> _WavesBuffer;

struct GerstnerOut
{
    float4 dispVector;
    float4 normalVector;
    float4 derivativeVector;
    float4 VelocityHeight;
};

float4 BilinearSamplerTextureArray(RWTexture2DArray<float4> TexArray, int2 coord, float RTSize, int PreviousLODIndex)
{
    int LODCount = (int)_LODParams.x;
    if (PreviousLODIndex > LODCount-1)
    {
        return float4(0.0, 0.0, 0.0, 0.0);
    }

    float2 UV = float2(coord.x * 0.5f + 0.25f * RTSize, coord.y * 0.5f + 0.25f * RTSize);

    //Bilinear Interpolation
    uint2 P00 = uint2(floor(UV.x), floor(UV.y));
    uint2 P10 = uint2(ceil(UV.x), floor(UV.y));
    uint2 P01 = uint2(floor(UV.x), ceil(UV.y));
    uint2 P11 = uint2(ceil(UV.x), ceil(UV.y));

    float4 sample00 = TexArray[uint3(P00, PreviousLODIndex)];
    float4 sample10 = TexArray[uint3(P10, PreviousLODIndex)];
    float4 sample01 = TexArray[uint3(P01, PreviousLODIndex)];
    float4 sample11 = TexArray[uint3(P11, PreviousLODIndex)];

    float2 xy = UV - floor(UV);

    float4 samplexy =
        sample00 * (1 - xy.x) * (1 - xy.y) +
        sample10 * (xy.x) * (1 - xy.y) +
        sample01 * (1 - xy.x) * (xy.y) +
        sample00 * (xy.x) * (xy.y);

   return samplexy;
}


GerstnerOut GetWaveDDNF(float3 OriginalWPos, int2 coord, float RTSize)
{
    float PI = 3.14159265f;

    int LODCount = (int)_LODParams.x;
    int LODIndex = (int)_LODParams.y;
    
    float3 displace = float3(0.0, 0.0, 0.0);

    float Dxx = 0.0f;
    float Dyy = 0.0f;
    float Dxy = 0.0f;
    float Dzx = 0.0f;
    float Dzy = 0.0f;
    //float Dzy = 0.0f;

    [unroll(10)]
    for (int i = 0; i < _WaveCount; i++)
    {

        float _WaveLength = _WavesBuffer[i].WaveLength;
        float k = 2 * PI / _WaveLength;
        float _Amplitude = _WavesBuffer[i].Amplitude * _LODWaveAmpMul;
        float _Steepness = _Amplitude * k;
        float _Speed = _WavesBuffer[i].Speed;
        float2 _Direction = normalize(_WavesBuffer[i].Direction);
        float f = k * (dot(OriginalWPos, float3(_Direction.x, 0, _Direction.y)) - _Time * _Speed);

        float Wx = _Amplitude * cos(f) * _Direction.x;
        float Wz = _Amplitude * cos(f) * _Direction.y;
        float Wy = _Amplitude * sin(f) * 1.0f;

        displace += float3(Wx, Wy, Wz);

        Dxx += -_Direction.x * _Direction.x * (_Steepness * sin(f));
        Dyy += -_Direction.y * _Direction.y * (_Steepness * sin(f));
        Dxy += -_Direction.x * _Direction.y * (_Steepness * sin(f));
        Dzx += _Direction.x * (_Steepness * cos(f));
        Dzy += _Direction.y * (_Steepness * cos(f));

       
        
    }
    
    //Sample the data (disp and derivative from Base LOD)
    float2 UV = float2(float(coord.x + 0.5f) / RTSize * 0.5f + 0.25f, float(coord.y + 0.5f) / RTSize * 0.5f + 0.25f);

    uint2 UVuint = uint2(coord.x * 0.5f + 0.25f * RTSize, coord.y * 0.5f + 0.25f * RTSize);

    //if the base is set to the current LOD, there are texture2D and RWTexture2D mapped to 
    //the same rendertexture in the same shader, the sample result is 0
    //turn out it is because all rwtex2d<float4> is not OK to sample and read at the same time 
    //float4 baseDisplaceV = _BaseDisplace.SampleLevel(linearClampSampler, UV, 0);
    //float4 baseDerivativeV = _BaseDerivativeMap_Sample.SampleLevel(linearClampSampler, UV, 0);

    //float4 baseDisplaceV;
    /*
    if (LODIndex == LODCount - 1)
    {
        baseDisplaceV = float4(0.0, 0.0, 0.0, 0.0);
    }
    else
    {
        baseDisplaceV = _DisplaceArray[uint3(UVuint, LODIndex + 1)];
    }
    */
    float4 baseDisplaceV = BilinearSamplerTextureArray(_DisplaceArray, coord, RTSize, LODIndex + 1);
    
    float4 baseDerivativeV = BilinearSamplerTextureArray(_DerivativeArray, coord, RTSize, LODIndex + 1);;



    Dxx += baseDerivativeV.x;
    Dyy += baseDerivativeV.y;
    Dxy += baseDisplaceV.w;
    Dzx += baseDerivativeV.z;
    Dzy += baseDerivativeV.w;
    displace += baseDisplaceV.xyz;
    

    //adding 1 is because we are calculating the D of offset
    //D(x+ dx01 + dx02)'x = 1+dxx01+dxx02 
    float3 tangent = normalize(float3(1.0f, 0.0f, 0.0f) + float3(Dxx, Dzx, Dxy));
    float3 binormal = normalize(float3(0.0f, 0.0f, 1.0f) + float3(Dxy, Dzy, Dyy));
    float3 normal = normalize(cross(binormal, tangent));
    //Jacobian Det from "Ocean Wave Rendering with Whitcap in the Visual System of a Maritime Simulaor"
    float JacobianDet = (1 + Dxx) * (1 + Dyy) - (Dxy) * (Dxy);
    float foam = clamp(1.0f - JacobianDet,0.0, 1.0);


    GerstnerOut ReturnData;
    ReturnData.dispVector = float4(displace, Dxy);
    ReturnData.normalVector = float4(normal, foam);
    ReturnData.derivativeVector = float4(Dxx, Dyy, Dzx, Dzy);

    return ReturnData;
}
//not used
float4 GetWaveHV(float3 WPos, float RTSize)
{
    float PI = 3.14159265f;

    float3 displace = float3(0.0, 0.0, 0.0);

    float Dxx = 0.0f;
    float Dyy = 0.0f;
    float Dxy = 0.0f;
    float Dzx = 0.0f;
    float Dzy = 0.0f;

    [unroll(10)]
    for (int i = 0; i < _WaveCount; i++)
    {

        float _WaveLength = _WavesBuffer[i].WaveLength;
        float k = 2 * PI / _WaveLength;
        float _Amplitude = _WavesBuffer[i].Amplitude * _LODWaveAmpMul;
        float _Steepness = _Amplitude * k;
        float _Speed = _WavesBuffer[i].Speed;
        float2 _Direction = normalize(_WavesBuffer[i].Direction);
        float f = k * (dot(WPos, float3(_Direction.x, 0, _Direction.y)) - _Time * _Speed);

        float Wy = _Amplitude * sin(f) * 1.0f;

        displace += float3(0.0, Wy, 0.0);

    }

    float CurrentLODSize = _LODParams.z;
    
    //Sample the data (disp and derivative from Base LOD)
    float2 coord = ((WPos.xz - _CenterPos.xz)/ CurrentLODSize +0.5f)*RTSize;
    float2 UV = float2(float(coord.x + 0.5f) / 512.0f * 0.5f + 0.25f, float(coord.y + 0.5f) / 512.0f * 0.5f + 0.25f);
    float4 baseDisplaceV = _BaseDisplace.SampleLevel(linearClampSampler, UV, 0);
    //float4 baseDerivativeV = _BaseDerivativeMap_Sample.SampleLevel(linearClampSampler, UV, 0);
    //baseNormalV = _BaseNormal.SampleLevel(linearClampSampler, UV, 0);

    displace += baseDisplaceV.xyz;
    
    return float4(0.0,0.0,0.0, displace.y);
}

[numthreads(32, 32, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{

    uint width, height, elements;
    _DisplaceArray.GetDimensions(width, height, elements);

    float CurrentLODSize = _LODParams.z;
    float LODIndex = _LODParams.y;

    //D3D CoordSystem
    float3 WPos = float3(
        (id.x / float(width) - 0.5f) * CurrentLODSize,
        0.0f,
        (id.y / float(height) - 0.5f) * CurrentLODSize
        ) + _CenterPos;
    
    //WPos *= 0.05f;

    //get all the in place data
    GerstnerOut outputWaveVectors = GetWaveDDNF(WPos, id.xy, width);//DDBF means Displace/Derivative/Normal/Foammask/Height/Velocity

    float4 outDisplaceV = outputWaveVectors.dispVector;
    float4 outDerivativeV = outputWaveVectors.derivativeVector;
    float4 outNormalV = outputWaveVectors.normalVector;

    //foam banding and progressive fade
    float FoamMask = clamp(pow(abs(outNormalV.a+ _FoamParams.y), _FoamParams.z),0.0,1.0);
    FoamMask = max(FoamMask, _NormalMap[id.xy].a * (1- _FoamParams.x));

    //Get the offset data(height and velocity)
    //float4 VelHVector = GetWaveHV(WPos + float3(outDisplaceV.x, 0, outDisplaceV.z), width);
    //assgin Temp map
    _DisplaceMap[id.xy] = outDisplaceV;
    _NormalMap[id.xy] = float4(outNormalV.rgb, FoamMask);
    _BaseDerivativeMap[id.xy] = outDerivativeV;

    //assign maps for CPU process
    _DisplaceArray[uint3(id.xy, LODIndex)] = outDisplaceV;
    _NormalArray[uint3(id.xy, LODIndex)] = float4(outNormalV.rgb, FoamMask);;
    _DerivativeArray[uint3(id.xy, LODIndex)] = outDerivativeV;
    //debug
    //Displace[id.xy] = _WaveLengths[10];
    //Result[id.xy] = float4(1.0f, 0.0f, 0.0f, 1.0f);
    /*
    if (length(WPos-float3(25,0,10)) < 12.0f)
        Result[id.xy] = float4(1, 0, 0, 0);
    else
        Result[id.xy] = float4(0.5f, 0.5f, 0.5f, 1.0f);
    */

    //Batches Normal


}




 //float2 UV = float2(float(id.x + 0.5f) / 512.0f * 1.0f, float(id.y + 0.5f) / 512.0f * 1.0f) + _Time / 100.0f;
 //float _FoamNoise = NoiseFoam.SampleLevel(samplerNoiseFoam, UV, 0).r;

//*****Crest Reference*****//
/*
for (uint vi = 0; vi < _NumWaveVecs; vi++)
{
    // direction
    half4 Dx = _WaveDirX[vi];
    half4 Dz = _WaveDirZ[vi];



    // Peferred wave direction
    #if CREST_DIRECT_TOWARDS_POINT_INTERNAL
    //wt *= max((1.0 + Dx * preferredDirX + Dz * preferredDirZ) / 2.0, 0.1);
    #endif



    // wave number
    half4 k = _TwoPiOverWavelengths[vi];
    // spatial location
    half4 x = Dx * worldPosXZ.x + Dz * worldPosXZ.y;
    half4 angle = k * x + _Phases[vi];



    // dx and dz could be baked into _ChopAmps
    //half4 disp = _ChopAmps[vi] * sin(angle);//invert

    //
    half4 steepnessY = k * _Amplitudes[vi];
    half4 steepnessXZ = k * _ChopAmps[vi];



    half4 resultx = -Dx * (steepnessXZ * cos(angle));
    half4 resultz = -Dz * (steepnessXZ * cos(angle));
    half4 resulty = 1 - steepnessY * sin(angle);



    result.x += dot(resultx, wt);
    result.y += dot(resulty, wt);
    result.z += dot(resultz, wt);
}
    */

    /*half4 disp = _ChopAmps[vi] * cos(angle);
    half4 resultx = disp * Dx;
    half4 resultz = disp * Dz;



    //half4 resulty = _Amplitudes[vi] * cos(angle);//invert
    half4 resulty = _Amplitudes[vi] * sin(angle);
    // sum the vector results
    result.x += dot(resultx, wt);
    result.y += dot(resulty, wt);
    result.z += dot(resultz, wt);



    half4 sssFactor = min(1.0, _TwoPiOverWavelengths[vi]);
    displacementNormalized.x += dot(resultx * sssFactor, wt);
    displacementNormalized.y += dot(resultz * sssFactor, wt);*/
