// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
/*
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> _BaseDisplace;//Previous LOD DispMap, RGB:displacement, A: Dxy
Texture2D<float4> _BaseNormal;//Previous LOD normal and foam Map, RGB:normal A:foam
//Texture2D<float4> _CurrNormal;//Same as _NormalMap just for sampling

//this map will be used though all LODs
RWTexture2D<float4> _BaseDerivativeMap;//Previous LOD DeriMap ,R: Dxx, G:Dyy, B:Dzx, A:Dzy
Texture2D<float4> _BaseDerivativeMap_Sample;//Same as _BaseDerivativeMap just for sampling

//sampler 
SamplerState linearClampSampler;
*/
RWTexture2D<float4> _DisplaceMap;//Displace Mapout for current LOD = disp + B_disp
RWTexture2D<float4> _NormalMap;//Normal out for current LOD normal and foam RGB:normal A:foam
//NormalMap will not be used by next LOD, but will be used by current LOD for foam fading
//Dxx.etc will add from previous LOD (A+B)' = A' + B'
//****Normal Cal****
//float3 tangent = normalize(float3(1.0f, 0.0f, 0.0f) + float3(Dxx, Dzx, Dxy));
//float3 binormal = normalize(float3(0.0f, 0.0f, 1.0f) + float3(Dxy, Dzy, Dyy));
//float3 normal = normalize(cross(binormal, tangent));
//****foam mask****
//float JacobianDet = (1 + Dxx) * (1 + Dyy) - (Dxy) * (Dxy);
//float FoamMask = clamp(1.0f - JacobianDet,0.0,1.0) * 0.1f + _NormalMap[id.xy].a * 0.9f ;

//Texture2D<float4> NoiseFoam;
//SamplerState samplerNoiseFoam;


float3 CenterPos;
float _LODSize;
//int _LODIndex;
float _LODWaveAmpMul;
float _Time;
float _DeltaTime;
int _WaveCount;
float _FoamFade;

const int LODCount = 8;

struct Wave
{
    float WaveLength;
    float Amplitude;
    float Speed;
    float2 Direction;
};
StructuredBuffer<Wave> _WavesBuffer;

struct GerstnerOut
{
    float4 dispVector;
    float4 normalVector;
    float4 derivativeVector;
};

GerstnerOut GetWaveSum(float3 OriginalWPos, int2 coord)
{
    float PI = 3.14159265f;

    float3 displace = float3(0.0, 0.0, 0.0);

    float Dxx = 0.0f;
    float Dyy = 0.0f;
    float Dxy = 0.0f;
    float Dzx = 0.0f;
    float Dzy = 0.0f;

    //float Dza = 0.0f;

    /*
    if (LODIndex < 7)
    {
        float2 UV = float2(float(coord.x +0.5f)/512.0f * 0.5f +0.25f, float(coord.y+0.5f)/512.0f*0.5f+0.25f);
        _Normal = normal;
        //_Normal = BaseNormal.SampleLevel(samplerBaseNormal, UV, 0);
        //displace += BaseDisplace.SampleLevel(samplerBaseDisplace, UV, 0);
            //BaseDisplace[HalfCoord].xyz;
        //normal += BaseNormal[coord].xyz;
        //displace += BaseDisplace[coord].xyz;
    }
    else
    {
        _Normal = float3(0.0f, 1.0f, 0.0f);
    }
    */
    for (int i = 0; i < _WaveCount; i++)
    {

        float _WaveLength = _WavesBuffer[i].WaveLength;
        float k = 2 * PI / _WaveLength;
        float _Amplitude = _WavesBuffer[i].Amplitude * _LODWaveAmpMul;
        float _Steepness = _Amplitude * k;
        float _Speed = _WavesBuffer[i].Speed;
        float2 _Direction = normalize(_WavesBuffer[i].Direction);
        float f = k * (dot(OriginalWPos, float3(_Direction.x, 0, _Direction.y)) - _Time * _Speed);

        float Wx = _Amplitude * cos(f) * _Direction.x;
        float Wz = _Amplitude * cos(f) * _Direction.y;
        float Wy = _Amplitude * sin(f) * 1.0f;

        displace += float3(Wx, Wy, Wz);

        Dxx += -_Direction.x * _Direction.x * (_Steepness * sin(f));
        Dyy += -_Direction.y * _Direction.y * (_Steepness * sin(f));
        Dxy += -_Direction.x * _Direction.y * (_Steepness * sin(f));
        Dzx += _Direction.x * (_Steepness * cos(f));
        Dzy += _Direction.y * (_Steepness * cos(f));

        //Dx * A *k * cos
        //Dx * A *k * -sin * k *Dx

        //Dzxx += _Direction.x * _Steepness * (-cos(f)) * k * _Direction.x;
        //Dzyy += _Direction.y * _Steepness * (-cos(f)) * k * _Direction.y;
        //Dza += _Direction.x * _Steepness * (-sin(f)) * k * _Direction.x;
        //Dza += _Direction.y * _Steepness * (-sin(f)) * k * _Direction.y;
        //tangent += float3(Dxx, _Direction.x * (_Steepness * cos(f)) * 1.0f, Dxy);

        //binormal += float3(Dxy, _Direction.y * (_Steepness * cos(f)) * 1.0f, Dyy);

        //JacobianDet += (1 + Dxx) * (1 + Dyy) - (1 + Dxy) * (1 + Dxy);
    }
    /*
    //fixed wave attenuation
    float4 wt = float4(1, 1, 1, 1);

    for (int n = 0; n < fmod(WaveCount, 4); n++)
    {

        float4 ks = 2 * PI / _WaveLengths[n];
        float4 Amplitudes = _Steepnesses[n] / ks;
        //later we have to this sqrt into CPU and integret it into Dir
        float4 Speeds = 0.1f;//sqrt(9.8 / k);
        float4 fs = ks * ((OriginalWPos.x * _DirXs[n] + OriginalWPos.z * _DirZs[n]) - _Time * Speeds);
        float4 Wxs = Amplitudes * cos(fs) * _DirXs[n];
        float4 Wzs = Amplitudes * cos(fs) * _DirZs[n];
        float4 Wys = Amplitudes * sin(fs);

        Displace += float3(dot(Wxs, wt), dot(Wys, wt), dot(Wzs, wt));
        Displace += ks.xyz;


        Displace += float3(WavesBatchBuffer[i].x, WavesBatchBuffer[i].y, WavesBatchBuffer[i].z);
    }
    */

    /*
    //Sample the data (disp and derivative from Base LOD)
    float2 UV = float2(float(coord.x + 0.5f) / 512.0f * 0.5f + 0.25f, float(coord.y + 0.5f) / 512.0f * 0.5f + 0.25f);
    float4 baseDisplaceV = _BaseDisplace.SampleLevel(linearClampSampler, UV, 0);
    float4 baseDerivativeV = _BaseDerivativeMap_Sample.SampleLevel(linearClampSampler, UV, 0);
    //baseNormalV = _BaseNormal.SampleLevel(linearClampSampler, UV, 0);
    Dxx += baseDerivativeV.x;
    Dyy += baseDerivativeV.y;
    Dxy += baseDisplaceV.w;
    Dzx += baseDerivativeV.z;
    Dzy += baseDerivativeV.w;
    displace += baseDisplaceV.xyz;
    */

    //adding 1 is because we are calculating the D of offset
    //D(x+ dx01 + dx02)'x = 1+dxx01+dxx02 
    float3 tangent = normalize(float3(1.0f, 0.0f, 0.0f) + float3(Dxx, Dzx, Dxy));
    float3 binormal = normalize(float3(0.0f, 0.0f, 1.0f) + float3(Dxy, Dzy, Dyy));
    float3 normal = normalize(cross(binormal, tangent));
    //Jacobian Det from "Ocean Wave Rendering with Whitcap in the Visual System of a Maritime Simulaor"
    float JacobianDet = (1 + Dxx) * (1 + Dyy) - (Dxy) * (Dxy);
    float foam = clamp(1.0f - JacobianDet,0.0, 1.0);


    GerstnerOut ReturnData;
    ReturnData.dispVector = float4(displace, Dxy);
    ReturnData.normalVector = float4(normal, foam);
    ReturnData.derivativeVector = float4(Dxx, Dyy, Dzx, Dzy);

    return ReturnData;
}

[numthreads(32, 32, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    uint width, height;
    _DisplaceMap.GetDimensions(width, height);

    //D3D CoordSystem
    float3 WPos = float3(
        (id.x / float(width) - 0.5f) * _LODSize,
        0.0f,
        (id.y / float(height) - 0.5f) * _LODSize
        ) + CenterPos;

    //WavesBuffer[0].WaveLength
    GerstnerOut outputWaveVectors = GetWaveSum(WPos, id.xy);

    float4 outDisplaceV = outputWaveVectors.dispVector;
    float4 outDerivativeV = outputWaveVectors.derivativeVector;
    float4 outNormalV = outputWaveVectors.normalVector;

    //float2 UV = float2(float(id.x + 0.5f) / 512.0f * 1.0f, float(id.y + 0.5f) / 512.0f * 1.0f) + _Time / 100.0f;
    //float _FoamNoise = NoiseFoam.SampleLevel(samplerNoiseFoam, UV, 0).r;

    float FoamMask = outNormalV.a * 0.1f + _NormalMap[id.xy].a * 0.9f ;
    //float FoamMask = (1.0f-Tangentout.z);


    _DisplaceMap[id.xy] = outDisplaceV;
    _NormalMap[id.xy] = float4(outNormalV.rgb, FoamMask);
    //_BaseDerivativeMap[id.xy] = outDerivativeV;

    //debug
    //Displace[id.xy] = _WaveLengths[10];
    //Result[id.xy] = float4(1.0f, 0.0f, 0.0f, 1.0f);
    /*
    if (length(WPos-float3(25,0,10)) < 12.0f)
        Result[id.xy] = float4(1, 0, 0, 0);
    else
        Result[id.xy] = float4(0.5f, 0.5f, 0.5f, 1.0f);
    */

    //Batches Normal


}





/*

for (uint vi = 0; vi < _NumWaveVecs; vi++)
{
    // direction
    half4 Dx = _WaveDirX[vi];
    half4 Dz = _WaveDirZ[vi];



    // Peferred wave direction
    #if CREST_DIRECT_TOWARDS_POINT_INTERNAL
    //wt *= max((1.0 + Dx * preferredDirX + Dz * preferredDirZ) / 2.0, 0.1);
    #endif



    // wave number
    half4 k = _TwoPiOverWavelengths[vi];
    // spatial location
    half4 x = Dx * worldPosXZ.x + Dz * worldPosXZ.y;
    half4 angle = k * x + _Phases[vi];



    // dx and dz could be baked into _ChopAmps
    //half4 disp = _ChopAmps[vi] * sin(angle);//invert

    //
    half4 steepnessY = k * _Amplitudes[vi];
    half4 steepnessXZ = k * _ChopAmps[vi];



    half4 resultx = -Dx * (steepnessXZ * cos(angle));
    half4 resultz = -Dz * (steepnessXZ * cos(angle));
    half4 resulty = 1 - steepnessY * sin(angle);



    result.x += dot(resultx, wt);
    result.y += dot(resulty, wt);
    result.z += dot(resultz, wt);
}
    */

    /*half4 disp = _ChopAmps[vi] * cos(angle);
    half4 resultx = disp * Dx;
    half4 resultz = disp * Dz;



    //half4 resulty = _Amplitudes[vi] * cos(angle);//invert
    half4 resulty = _Amplitudes[vi] * sin(angle);
    // sum the vector results
    result.x += dot(resultx, wt);
    result.y += dot(resulty, wt);
    result.z += dot(resultz, wt);



    half4 sssFactor = min(1.0, _TwoPiOverWavelengths[vi]);
    displacementNormalized.x += dot(resultx * sssFactor, wt);
    displacementNormalized.y += dot(resultz * sssFactor, wt);*/
